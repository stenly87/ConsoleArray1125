// See https://aka.ms/new-console-template for more information
goto lesson2609;
lesson2509:
// массивы в c#
// статический тип данных
// хранит множество значений определенного типа
// существует два видов массивов с точки зрения
// размерности: одномерный и n-мерный

// одномерный массив создается так:

// тип[] названиеМассива;
// инициализация одномерного массива:
// названиеМассива = new тип[размер];
// названиеМассива = new тип[размер]{эл1, эл2}; // в этом случае кол-во элементов в {} должно равняться размеру
// названиеМассива = new тип[]{эл1, эл2};// в этом случае размер вычисляется из указанных элементов
// [] пустые квадратные скобки указывают на то, что
// массив одномерный
int[] array = new int[] { 1, 2 };

// сокращенный вариант
array = [5, 6];

// если нужен 2-мерный массив, между квадратных скобок указывается запятая
string[,] strings = new string[2,2];
// инициализация двумерного массива предполагает указание
// размера для каждой плоскости
// пример инициализации двумерного массива с указанием значений
string[,] strings2 = new string[2, 2] 
    { {"1", "2" }, { "3", "4"} };

// пример работы с ячейками, одномерный массив
array[0] = 10; // запись ячейки
int value = array[1]; // чтение ячейки
for(int i = 0; i < array.Length; i++)
    Console.WriteLine(array[i]);

// ошибка! в массиве array есть всего две ячейки, индексы: 0 и 1
//var tryMe = array[2];

Console.WriteLine($"Длина массива array: {array.Length}");

// массивы в c# являются неизменяемыми с точки зрения длины
// в случае, если нам не хватает массива и нужны дополнительные ячейки
// нужно создать новый массив, скопировать туда значения из старого массива
// и переназначить ссылку по необходимости

{
    int[] newArray = new int[5];
    for (int i = 0; i < array.Length; i++)
        newArray[i] = array[i]; // копирование старых значений

    // альтернативый вариант копирования старых значений
    array.CopyTo(newArray, 3); // 3 - индекс в новом массиве, откуда начнется запись значений из старого массива
    // еще одна альтернатива - создатся новый массив, скопируются данные, ссылка будет переназначена на новый массив
    //Array.Resize(ref array, 5);

    // можно сделать так, чтобы старая переменная array
    // стала указывать на новый массив
    array = newArray;
}

// повторный вывод обновленного массива
for (int i = 0; i < array.Length; i++)
    Console.WriteLine(array[i]);

// работа с двумерным массивом
strings2[0, 0] = "Привет";
int allCellCount = strings2.Length; // сколько всего ячеек
int rows = strings2.GetLength(0); // кол-во строк
int cols = strings2.GetLength(1); // кол-во столбцов

// перебор элементов в двумерном массиве
// перебираем строки
for (int i = 0; i < rows; i++)
{   // перебираем столбцы
    for (int j = 0; j < cols; j++)
    {
        Console.WriteLine(strings2[i,j]);
    }
}
Console.WriteLine();

//var - определение типа из контекста
//var test = 1; // без значения нельзя создать переменную с помощью слова var
// происходит перебор всех ячеек, независимо от 
// размерности массива
foreach (var cell in strings2)
{
    // в переменную cell производится копирование ссылки
    // на каждую ячейку в массиве
    Console.WriteLine(cell);
    //cell = "adsas"; // мы не можем изменить значения в массиве с помощью переменной цикла foreach
}
// пример трехмерного массива
byte[,,] bytes = new byte[10, 2, 2];
bytes[0, 0, 0] = 0;

// 11.26
Console.WriteLine("Размер массива?");
int.TryParse(Console.ReadLine(), out int lenght);

Random random = new Random();

int[] ints = new int[lenght];
for (int i = 0; i < ints.Length; i++)
{
    // вариант с генерацией значений
    ints[i] = random.Next(-100, 101);
    // вариант с ручным вводом
    //Console.Write("Введите {i}-ый элемент: ");
    //int.TryParse(Console.ReadLine(), out ints[i]);  
}

for (int i = 0; i < ints.Length; i++)
    if (ints[i] >= 0)
        Console.WriteLine(ints[i]);

for (int i = 0; i < ints.Length; i++)
    if (ints[i] < 0)
        Console.WriteLine(ints[i]);

//

lesson2609:

// лекция на тему "Методы в c#"

// метод - обособленный блок кода в классе. Метод
// имеет имя, тип возвращаемого значения и набор аргументов
// синтаксис для создания метода:
/*
тип Имя(аргументы)
{ 
 тело метода
}
*/

// пример метода, который возвращает значение типа int
// имеет имя Sum и два аргумента x и y типа int
// в методах с определенным типом возращаемого значения
// обязательно должно быть завершение с помощью
// ключевого слова return, после которого идет значение
int Sum(int x, int y)
{
    return x + y;
}
// вызов метода на исполнение с получением его результата
int _test_9;
int Test1;
int nTest2;
int nTest3;

// в переменную z
int z = Sum(10, 15);
// значение z копируется в аргумент, потом перезаписывается
// результатом метода
z = Sum(z, 15);
// пример метода, который не возвращает значения (void)
// и не имеет аргументов
// return для завершения не нужен, но при необходимости
// прервать выполнение метода можно использовать return;
void SaySomething()
{
    Console.WriteLine("Something");
}
// вызов метода без аргументов идет все равно со скобками
SaySomething();


// аргументов в методе может быть 0 и более
// могут быть специальные ключевые слова (ref, out, params)
// могу быть аргументы со значением по умолчанию
// ref - передача аргумента по ссылке независимо от типа
// значение такой переменной может измениться внутри метода
// и сохранится после его завершения
int Mult(ref int x, int y)
{
    x = x * y;
    return x;
}

Console.WriteLine(z);
Console.WriteLine(Mult(ref z, 15));
Console.WriteLine(z);

// out - назначает значение в переменную, переданную
// в аргумент с ключевым словом out
// в данном методе аргумент y идет с ключевым словом out
// 1. мы должны назначить значение аргументу y
// 2. переменная, переданная в аргумент y, получит значение
// при выполнении метода
void MultOut(int x, out int y)
{
    y = 10 * x;
}

MultOut(10, out z);
Console.WriteLine(z);

// что-то типа этого есть в unity:
// raycast возвращает ссылку на объект
// а в доп. аргументах возращает расстояние до объекта и другую информацию
//object Target = raycast(out double distance);

// params позволяет создать метод, в который можно передать
// переменное число аргументов заданного типа
// такой аргумент всегда идет в конце списка аргументов
// первый аргумент Х обычный, за ним идет массив 
// при этом мы можем передать значения как массивом, так и 
// через запятую
int SumParams(int x, params int[] y)
{
    return x + y.Sum();
}
// пример использования params
z = SumParams(10, [1, 2, 3, 4]);
Console.WriteLine(z);
z = SumParams(15, 14, 2, 3, 5, 1, 3, 3);
Console.WriteLine(z);

// аргументы со значением по умолчанию
int MultDefault(int x = 10, int y = 10)
{ 
    return x + y;
}

// здесь ни один аргумент не указан, будут использованы
// значения по умолчанию x = 10,y = 10
z = MultDefault();
// здесь задан Х = 100, y = 10
z = MultDefault(100);
// x = 10. Аргумент y указан принудительно
z = MultDefault(y: 200);

// аргументы могут назначаться принудительно путем 
// указания их имени и значения через двоеточие
// обязательные аргументы (без значения по умолчанию)
// всегда должны быть назначены

Program.Main();

partial class Program
{
    // Методы могут быть созданы с одинаковыми именами
    // но при этом у них должен быть разный набор аргументов
    // это соблюдение принципа полиморфизма в ООП
    static float Mult(string x, string y)
    {
        return 1.0f;
    }

    float Mult(float x, float y)
    {
        return 1.0f;
    }

    float Mult(string x, string y, string z)
    {        
        return 1.0f;
    }
    // существует ключевое слово static
    // оно позволяет использовать методы и другие элементы класса без создания 
    // экземпляра класса
    // статичные методы и свойства имеют доступ
    // к другим статичным методам и свойствам
    // нестатичные элементы имеют доступ ко всем другим
    // элементам в классе
    // статичные элементы создаются один раз для класса

    public static void Main()
    {
        Console.WriteLine(Mult("123", "456"));
    }
}

